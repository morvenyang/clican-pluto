= DPL使用手册 =

==第一章 DPL交互接口==

所有的和DPL模块的交互方式的唯一接口就是通过一个`DplStatement`接口,String的dpl参数和一个Map(List和常量的存放的Map)来进行数据运算和关联。

一共有4个重构接口。主要的参数请参见下表:

||参数名||参数名描述||
||dpl||类似于sql的一个字符串，用于数据处理的一个描述字符串类似于select userList.name,userList.password from userList where userList.id=1 or userList.id = dual.id||
||`ProcessorContext`||用于dpl数据处理的一个Map对象,其中包含了userList之类的集合变量用于from,还包含了dual.id这类的常量用于常量替换。||
||Map<String,Object>||功用和`ProcessorContext`一样,只是一个简单的函数复载Clazz`<T>`用于dpl返回List内保存的对象的类型转换,通过这个参数可以把Map对象转换为T对象。前提就是Map中的key需要和T对象的属性能够名称上对应上。||

{{{
/**
 * The Clican-Pluto software suit is Copyright 2009, Clican Company and individual contributors, and is licensed under the GNU LGPL.
 *
 * @author clican
 *
 */
package com.clican.pluto.dataprocess.dpl;

import java.util.List;
import java.util.Map;

import com.clican.pluto.dataprocess.engine.ProcessorContext;
import com.clican.pluto.dataprocess.exception.DplException;

/**
 * Data Process Language的处理类，该类的实现接口可以用来根据dpl描述的查询语句
 * <code>ProcessorContext</code>的上下文中把希望获得的数据各类where条件、group by条件order
 * by条件再经过各个calculation计算获得结果。
 * 
 * @author clican
 * 
 */
public interface DplStatement {

	/**
	 * 
	 * @param <T>
	 * @param dpl
	 *            dpl data process language
	 * @param context
	 *            数据来源的上下文
	 * @param clazz
	 *            把查询得到的结果转换为该数据类型，要求必须查询结果的as名称和他的property
	 *            name完全一致。该clazz必须有一个没有参数的构造函数。
	 * @return
	 * @throws DplException
	 *             如果在解析dpl或执行dpl的过程中出现错误则抛出该异常
	 */
	public <T> List<T> execute(String dpl, ProcessorContext context, Class<T> clazz) throws DplException;

	/**
	 * 
	 * @param dpl
	 *            data process language
	 * @param context
	 *            数据来源的上下文
	 * @return
	 * @throws DplException
	 *             如果在解析dpl或执行dpl的过程中出现错误则抛出该异常
	 */
	public List<Map<String, Object>> execute(String dpl, ProcessorContext context) throws DplException;

	/**
	 * 
	 * @param <T>
	 * @param dpl
	 *            data process language
	 * @param context
	 *            数据来源的上下文
	 * @param clazz
	 *            把查询得到的结果转换为该数据类型，要求必须查询结果的as名称和他的property
	 *            name完全一致。该clazz必须有一个没有参数的构造函数。
	 * @return
	 * @throws DplException
	 */
	public <T> List<T> execute(String dpl, Map<String, Object> context, Class<T> clazz) throws DplException;

	/**
	 * 
	 * @param dpl
	 *            data process language
	 * @param context
	 *            数据来源的上下文
	 * @return
	 * @throws DplException
	 */
	public List<Map<String, Object>> execute(String dpl, Map<String, Object> context) throws DplException;

}

// $Id: DplStatement.java 13278 2010-05-26 11:29:38Z wei.zhang $
}}}


==第二章 常用操作==
以下所有的数据操作都基于如下数据
list1
||name||value||date||
||000001||1.1||2008-2-1||
||000001||1.0||2008-2-2||
||000001||1.1||2008-2-3||
||000001||0.9||2008-2-5||
||000002||2.1||2008-2-1||
||000002||2.2||2008-2-3||
||000002||1.8||2008-2-4||
||000002||1.9||2008-2-6||

list2
||name||value||date||
||000001||0.1||2008-2-2||
||000001||0.2||2008-2-4||
||000002||0.1||2008-2-2||
||000002||0.4||2008-2-4||

list3
||name||value||date||
||000001||0.01||2008-2-2||

===简单数据过滤===
过滤出所有的name=000001的list1的数据
{{{
select list1.* from list1 where list1.name='000001'
}}}

这里值得注意的是对于000001这么一个字符串常量需要用单引号括起来，单对于数字的话则不需要但引号。目前支持的常量类型只有字符串和数字。同时也需要注意的是如果在`ProcessorContext`和Map中有key=name value=000001的一条记录的话该条dpl也能转换为
{{{
select list1.* from list1where list1.name= dual.name
}}}
其中的dual就代表从`ProcessorContext`和Map中取得一个常量。

得到的结果集合

||name||value||date||
||000001||1.1||2008-2-1||
||000001||1.0||2008-2-2||
||000001||1.1||2008-2-3||
||000001||0.9||2008-2-5||